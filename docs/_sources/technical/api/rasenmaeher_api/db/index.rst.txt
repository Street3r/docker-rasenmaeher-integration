:py:mod:`rasenmaeher_api.db`
============================

.. py:module:: rasenmaeher_api.db

.. autoapi-nested-parse::

   Gino based database abstraction



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   base/index.rst
   config/index.rst
   enrollments/index.rst
   errors/index.rst
   logincodes/index.rst
   middleware/index.rst
   nonces/index.rst
   people/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   rasenmaeher_api.db.DBConfig
   rasenmaeher_api.db.Person
   rasenmaeher_api.db.Role
   rasenmaeher_api.db.Enrollment
   rasenmaeher_api.db.EnrollmentPool
   rasenmaeher_api.db.EnrollmentState
   rasenmaeher_api.db.SeenToken
   rasenmaeher_api.db.LoginCode



Functions
~~~~~~~~~

.. autoapisummary::

   rasenmaeher_api.db.bind_config
   rasenmaeher_api.db.init_db



Attributes
~~~~~~~~~~

.. autoapisummary::

   rasenmaeher_api.db.db


.. py:class:: DBConfig


   DB config dataclass, functools etc used to avoid import-time side-effects

   .. py:attribute:: driver
      :type: str

      

   .. py:attribute:: host
      :type: Optional[str]

      

   .. py:attribute:: port
      :type: int

      

   .. py:attribute:: user
      :type: Optional[str]

      

   .. py:attribute:: password
      :type: starlette.datastructures.Secret

      

   .. py:attribute:: database
      :type: str

      

   .. py:attribute:: dsn
      :type: Optional[sqlalchemy.engine.url.URL]

      

   .. py:attribute:: pool_min_size
      :type: int

      

   .. py:attribute:: pool_max_size
      :type: int

      

   .. py:attribute:: echo
      :type: bool

      

   .. py:attribute:: ssl
      :type: str

      

   .. py:attribute:: use_connection_for_request
      :type: bool

      

   .. py:attribute:: retry_limit
      :type: int

      

   .. py:attribute:: retry_interval
      :type: int

      

   .. py:attribute:: _singleton
      :type: ClassVar[Optional[DBConfig]]

      

   .. py:method:: singleton(**kwargs)
      :classmethod:

      Get a singleton


   .. py:method:: __post_init__()

      Post init stuff



.. py:data:: db

   

.. py:function:: bind_config()
   :async:

   Set bind from config and return


.. py:function:: init_db()
   :async:

   Create schemas and tables, normally one should use migration manager


.. py:class:: Person


   Bases: :py:obj:`rasenmaeher_api.db.base.BaseModel`

   People, pk is UUID and comes from basemodel

   NOTE: at some point we want to stop keeping track of people in our own db
   and only use keycloack as the store for actual users. In any case we need a nice pythonic
   abstraction layer so implement any queries you need to add as helpers here.

   .. py:class:: Config


      Basemodel config

      .. py:attribute:: extra

         


   .. py:attribute:: __tablename__
      :value: 'users'

      

   .. py:attribute:: callsign

      

   .. py:attribute:: certspath

      

   .. py:attribute:: extra

      

   .. py:method:: create_with_cert(callsign, extra = None)
      :classmethod:
      :abstractmethod:
      :async:

      Create the cert etc and save the person


   .. py:method:: list(include_deleted = False)
      :classmethod:
      :async:

      List people


   .. py:method:: by_role(role)
      :classmethod:
      :async:

      List people that have given role, if role is None list all people


   .. py:method:: by_callsign(callsign, allow_deleted = False)
      :classmethod:
      :async:

      Get by callsign


   .. py:method:: by_mtlsjwt_payload(payload, allow_deleted = False)
      :classmethod:
      :async:

      Get by MTLSorJWTMiddleWare payload


   .. py:method:: get_key_pem()
      :abstractmethod:
      :async:

      Read the private key from under certspath and return the PEM


   .. py:method:: get_cert_pem()
      :abstractmethod:
      :async:

      Read the cert from under certspath and return the PEM


   .. py:method:: get_cert_pfx()
      :abstractmethod:
      :async:

      Read the cert and private key from under certspath and return the PFX container


   .. py:method:: _get_role(role)
      :async:

      Internal helper for DRY


   .. py:method:: has_role(role)
      :async:

      Check if this user has given role


   .. py:method:: assign_role(role)
      :async:

      Assign a role, return true if role was created, false if it already existed


   .. py:method:: remove_role(role)
      :async:

      Remove a role, return true if role was removed, false if it wasn't assigned



.. py:class:: Role


   Bases: :py:obj:`rasenmaeher_api.db.base.DBModel`

   Give a person a role

   .. py:attribute:: __tablename__
      :value: 'roles'

      

   .. py:attribute:: __table_args__

      

   .. py:attribute:: pk

      

   .. py:attribute:: created

      

   .. py:attribute:: updated

      

   .. py:attribute:: user

      

   .. py:attribute:: role

      

   .. py:attribute:: _idx

      


.. py:class:: Enrollment


   Bases: :py:obj:`rasenmaeher_api.db.base.BaseModel`

   Enrollments, pk is UUID and comes from basemodel

   .. py:class:: Config


      Basemodel config

      .. py:attribute:: extra

         


   .. py:attribute:: __tablename__
      :value: 'enrollments'

      

   .. py:attribute:: approvecode

      

   .. py:attribute:: callsign

      

   .. py:attribute:: decided_on

      

   .. py:attribute:: decided_by

      

   .. py:attribute:: person

      

   .. py:attribute:: pool

      

   .. py:attribute:: state

      

   .. py:attribute:: extra

      

   .. py:method:: approve(approver)
      :async:

      Creates the person record, their certs etc


   .. py:method:: reject(decider)
      :async:

      Reject


   .. py:method:: by_callsign(callsign)
      :classmethod:
      :async:

      Get by callsign


   .. py:method:: by_approvecode(code)
      :classmethod:
      :async:

      Get by approvecode


   .. py:method:: create_for_callsign(callsign, pool = None, extra = None)
      :classmethod:
      :async:

      Create a new one with random code for the callsign


   .. py:method:: delete()
      :async:

      Deletion of enrollments is not allowed



.. py:class:: EnrollmentPool


   Bases: :py:obj:`rasenmaeher_api.db.base.BaseModel`

   Enrollment pools aka links, pk is UUID and comes from basemodel

   .. py:class:: Config


      Basemodel config

      .. py:attribute:: extra

         


   .. py:attribute:: __tablename__
      :value: 'enrollmentpools'

      

   .. py:attribute:: owner

      

   .. py:attribute:: active

      

   .. py:attribute:: extra

      

   .. py:method:: create_enrollment(callsign)
      :async:

      Create enrollment from this pool


   .. py:method:: set_active(state = True)
      :async:

      Set active and return refreshed object



.. py:class:: EnrollmentState


   Bases: :py:obj:`enum.IntEnum`

   Enrollment states

   .. py:attribute:: PENDING
      :value: 0

      

   .. py:attribute:: APPROVED
      :value: 1

      

   .. py:attribute:: REJECTED
      :value: 2

      


.. py:class:: SeenToken


   Bases: :py:obj:`rasenmaeher_api.db.base.BaseModel`

   Store tokens we should see used only once

   .. py:class:: Config


      Basemodel config

      .. py:attribute:: extra

         


   .. py:attribute:: __tablename__
      :value: 'seentokens'

      

   .. py:attribute:: token

      

   .. py:attribute:: auditmeta

      

   .. py:method:: use_token(token, auditmeta = None)
      :classmethod:
      :async:

      Use token if it was already used raise error that is also 403


   .. py:method:: by_token(token)
      :classmethod:
      :async:

      Get by token


   .. py:method:: delete()
      :async:

      Deletion of enrollments is not allowed



.. py:class:: LoginCode


   Bases: :py:obj:`rasenmaeher_api.db.base.BaseModel`

   Track the login codes that can be exchanged for session JWTs

   .. py:class:: Config


      Basemodel config

      .. py:attribute:: extra

         


   .. py:attribute:: __tablename__
      :value: 'logincodes'

      

   .. py:attribute:: code

      

   .. py:attribute:: auditmeta

      

   .. py:attribute:: used_on

      

   .. py:attribute:: claims

      

   .. py:method:: use_code(code, auditmeta = None)
      :classmethod:
      :async:

      Exchange the code for JWT, if it was already used raise error that is also 403, return JWT with the claims


   .. py:method:: by_code(code)
      :classmethod:
      :async:

      Get by token


   .. py:method:: create_for_claims(claims, auditmeta = None)
      :classmethod:
      :async:

      Create a new one with random code for the given claims


   .. py:method:: delete()
      :async:

      Deletion of enrollments is not allowed



