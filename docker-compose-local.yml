version: '3.4'

x-kc_dbconfig_env: &kcdbconfig_env
  KEYCLOAK_DATABASE_NAME: &kcdbname keycloak
  KEYCLOAK_DATABASE_HOST: postgres
  KEYCLOAK_DATABASE_USER: &kcdbuser keycloak
  # FIXME: take from env (which should be set to random)
  KEYCLOAK_DATABASE_PASSWORD: &kcdbpass keycloakpwd # pragma: allowlist secret

x-postgres_env: &postgres_env
  KEYCLOAK_PASSWORD: *kcdbpass # pragma: allowlist secret
  POSTGRES_PASSWORD: "FIXME: change to long random" # pragma: allowlist secret


x-ldap_admin_env: &ldap_admin_env
  # FIXME: take from env (which should be set to random)
  LDAP_ADMIN_PASSWORD: &ldapadminpass ldapadminpwd # pragma: allowlist secret
  LDAP_ADMIN_USERNAME: &ldapadminuser admin

x-keycloak_users_env: &keycloak_users_env
  KEYCLOAK_CREATE_ADMIN_USER: true
  KEYCLOAK_ADMIN_USER: &lcadminuser admin
  KEYCLOAK_MANAGEMENT_USER: damager
  # FIXME: take from env (which should be set to random)
  KEYCLOAK_ADMIN_PASSWORD: &kcadminpass kcadminpw # pragma: allowlist secret
  KEYCLOAK_MANAGEMENT_PASSWORD: kcmgrpw # pragma: allowlist secret

x-keycloak_profile_env: &keycloak_profile_env
  # These can be expanded in keycloak-config/profile.json
  KCP_REALM: "RASENMAEHER"
  KCP_MAIN_ID: "4f88fe8c-ffa5-4ae4-97c9-3831a500d502"  # FIXME: get from env or something

x-keycloakinit_users_env: &keycloakinit_users_env
  KEYCLOAK_USER: *lcadminuser # pragma: allowlist secret
  KEYCLOAK_PASSWORD: *kcadminpass # pragma: allowlist secret

services:
  fakewerk:
    image: pvarki/fakewerk:latest
    build:
      context: ./fakewerk
      dockerfile: Dockerfile
      target: production
    environment:
      RASENMAEHER_HOST: ${SERVER_DOMAIN:-localmaeher.pvarki.fi}
      RASENMAEHER_HTTPS_PORT: ${NGINX_HTTPS_PORT:-4439}
    volumes:
      - kraftwerk_shared:/pvarki
      - kraftwerk_data:/data/persistent

  cfssl:
    image: pvarki/cfssl:latest
    build:
      context: ./cfssl
      dockerfile: Dockerfile
    networks:
      - canet
    environment:
      # This does not seem to work correctly, I had to manually mount the volume and copy a chain there
      INT_SHARED_CERT_FOLDER: /ca_public
      CFSSL_BIND_ADDRESS: ${CFSSL_BIND_ADDRESS:-0.0.0.0}
      CFSSL_BIND_PORT: ${CFSSL_BIND_PORT:-8888}
    volumes:
      - cfssl_data:/opt/cfssl/persistent
      - ca_public:/ca_public
    healthcheck:
      test: 'true'  # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

  rmmkcert:
    image: pvarki/mkcert:latest
    build:
      context: ./mkcert
      dockerfile: Dockerfile
      target: production
    environment:
      SERVER_DOMAIN: ${SERVER_DOMAIN:-localmaeher.pvarki.fi}
      CAROOT: /caroot
    volumes:
      - mkcert_ca:/caroot
      - le_certs:/certs
      - ca_public:/ca_public

  postgres:
    image: postgres:12
    networks:
      - dbnet
    volumes:
      - ./pg_init:/docker-entrypoint-initdb.d
      - pg_data:/var/lib/postgresql/data
      - ca_public:/ca_public
    environment:
      <<: *postgres_env
    depends_on:
      cfssl:
        condition: service_healthy
    healthcheck:
      test: "pg_isready --dbname=$$POSTGRES_DB --username=$$POSTGRES_USER"
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

  openldap:
    image: pvarki/openldap:latest
    build:
      context: ./openldap
      dockerfile: Dockerfile
    networks:
      - kcnet
      - dbnet
    ports:
      - '1636:1636'  # LDAPs
    environment:
      <<: *ldap_admin_env
      LDAP_SKIP_DEFAULT_TREE: yes
      LDAP_ALLOW_ANON_BINDING: no
      # FIXME: get from env ??
      LDAP_ROOT: "dc=example,dc=org"  # Probably needs to match the custom ldfis
      LDAP_LOGLEVEL: 0
      LDAP_ENABLE_TLS: yes
      LDAP_TLS_CERT_FILE: /le_certs/${SERVER_DOMAIN:-localmaeher.pvarki.fi}/fullchain.pem
      LDAP_TLS_KEY_FILE: /le_certs/${SERVER_DOMAIN:-localmaeher.pvarki.fi}/privkey.pem
      LDAP_TLS_CA_FILE: /ca_public/ca_chain.pem
      LDAP_TLS_DH_PARAM_FILENAME: /dhparam.pem
    volumes:
      - openldap_data:/bitnami/openldap
      - ca_public:/ca_public
      - le_certs:/le_certs
      - ./nginx/includes/dhparam.pem:/dhparam.pem
    depends_on:
      rmmkcert:
        condition: service_completed_successfully
      cfssl:
        condition: service_healthy
    healthcheck:
      # This started returning: No such object (32)
      #test: 'ldapsearch -Q -tt -LLL -Y EXTERNAL -H ldapi:/// "(uid=testuser)" -b dc=example,dc=org memberOf'
      test: "true" # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 15s

  keycloak:
    image: bitnami/keycloak:latest
    environment:
      <<: [*kcdbconfig_env, *keycloak_users_env]
      KC_HEALTH_ENABLED: true
    networks:
      - kcnet
      - dbnet
    volumes:
      - ca_public:/ca
    depends_on:
      openldap:
        condition: service_healthy
      postgres:
        condition: service_healthy
    healthcheck:
      test: "curl -s localhost:8080/health/ready | grep status | grep UP"
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 15s

  # init container that sets up profile with realm on keycloak instance
  keycloak-init:
    image: adorsys/keycloak-config-cli:latest-21.0.1
    networks:
      - kcnet
    volumes:
      - ./keycloak/keycloak-config:/config
      - ca_public:/ca
    environment:
      <<: [*keycloak_profile_env, *ldap_admin_env, *keycloakinit_users_env]
      KEYCLOAK_URL: http://keycloak:8080
      KEYCLOAK_SSL-VERIFY: false  # We are using the internal port
      KEYCLOAK_AVAILABILITYCHECK_ENABLED: true
      KEYCLOAK_AVAILABILITYCHECK_TIMEOUT: 30s
      IMPORT_VAR_SUBSTITUTION_ENABLED: true
      LDAP_CONNECTION_URL: ldap://openldap:1389
    depends_on:
      keycloak:
        condition: service_healthy

  rmapi:
    image: pvarki/rmapi:latest
    build:
      context: ./api
      dockerfile: Dockerfile
      target: production
    ports:
      - "8000:8000"  # NOTE: Do *NOT* expose this in production, always pass through NGinx proxy
    environment:
      JWT_PUBKEY_PATH: "/pvarki/publickeys"
      JWT_PRIVKEY_PATH: "/data/persistent/jwt.key"
      JWT_PRIVKEY_PASS: "localmaeherjwtkeypass"  # pragma: allowlist secret
      RM_CFSSL_HOST: "http://cfssl"
      RM_CFSSL_PORT: ${CFSSL_BIND_PORT:-8888}
    networks:
      - apinet
      - kcnet
      - canet
    volumes:
      - ca_public:/ca_public
      - rmapi_data:/data/persistent
      - kraftwerk_shared:/pvarki
    depends_on:
      cfssl:
        condition: service_healthy
      keycloak:
        condition: service_healthy
      keycloak-init:
        condition: service_completed_successfully
      fakewerk:
        condition: service_completed_successfully
    healthcheck:
      test: 'true'  # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

  rmnginx:
    image: nginx
    volumes:
      - ./nginx/templates:/etc/nginx/templates
      - ./nginx/includes:/etc/nginx/includes
      - ca_public:/ca_public
      - le_certs:/le_certs
    environment:
      NGINX_HOST: ${SERVER_DOMAIN:-localmaeher.pvarki.fi}
      NGINX_HTTP_PORT: ${NGINX_HTTP_PORT:-8015}
      NGINX_HTTPS_PORT: ${NGINX_HTTPS_PORT:-4439}
      NGINX_UPSTREAM: "rmapi"
      NGINX_UPSTREAM_PORT: "8000"
    networks:
      - apinet
      - kcnet
    ports:
      - "${NGINX_HTTP_PORT:-8015}:${NGINX_HTTP_PORT:-8015}"
      - "${NGINX_HTTPS_PORT:-4439}:${NGINX_HTTPS_PORT:-4439}"
    depends_on:
      rmmkcert:
        condition: service_completed_successfully
      keycloak:
        condition: service_healthy
      rmapi:
        condition: service_healthy
    healthcheck:
      test: 'true'  # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

  kwinit:  # Mostly to make sure it's built
    image: pvarki/kw_product_init:latest
    build:
      context: ./kw_product_init
      dockerfile: Dockerfile
      target: production
    command: ["help"]
    volumes:
      - ca_public:/ca_public
      - le_certs:/le_certs
      - kraftwerk_shared:/pvarki
      - kwinit_data:/data/persistent

  rmfpapi:
    image: pvarki/rmfpapi:latest
    build:
      context: ./fpintegration
      dockerfile: Dockerfile
      target: production
    ports:
      - "8001:8001"  # NOTE: Do *NOT* expose this in production, always pass through NGinx proxy
    networks:
      - productnet
    volumes:
      - ca_public:/ca_public
      - kraftwerk_shared:/pvarki
      - rmfpapi_data:/data/persistent
    depends_on:
      rmnginx:
        condition: service_healthy
    healthcheck:
      test: 'true'  # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

  fpmkcert:
    image: pvarki/mkcert:latest
    build:
      context: ./mkcert
      dockerfile: Dockerfile
      target: production
    environment:
      SERVER_DOMAIN: "fake.${SERVER_DOMAIN:-localmaeher.pvarki.fi}"
      CAROOT: /caroot
    volumes:
      - mkcert_ca:/caroot
      - le_certs:/certs

  fpnginx:
    image: nginx
    volumes:
      - ./nginx/templates:/etc/nginx/templates_onlymtls
      - ./nginx/includes:/etc/nginx/includes
      - ca_public:/ca_public
      - le_certs:/le_certs
    environment:
      NGINX_HOST: "fake.${SERVER_DOMAIN:-localmaeher.pvarki.fi}"
      NGINX_HTTP_PORT: ${NGINX_HTTP_PRODUCT_PORT:-8016}
      NGINX_HTTPS_PORT: ${NGINX_HTTPS_PRODUCT_PORT:-4625}
      NGINX_UPSTREAM: "rmfpapi"
      NGINX_UPSTREAM_PORT: "8001"
    networks:
      - productnet
    ports:
      - "${NGINX_HTTP_PRODUCT_PORT:-8016}:${NGINX_HTTP_PRODUCT_PORT:-8016}"
      - "${NGINX_HTTPS_PRODUCT_PORT:-4625}:${NGINX_HTTPS_PRODUCT_PORT:-4625}"
    depends_on:
      fpmkcert:
        condition: service_completed_successfully
      rmfpapi:
        condition: service_healthy
    healthcheck:
      test: 'true'  # FIXME
      interval: 5s
      timeout: 5s
      retries: 3
      start_period: 5s

networks:
  productnet:
  apinet:
  kcnet:
  canet:
  dbnet:

volumes:
  kraftwerk_data:
  kwinit_data:
  kraftwerk_shared:
  pg_data:
  cfssl_data:
  openldap_data:
  rmapi_data:
  rmfpapi_data:
  ca_public:
  le_certs:
  mkcert_ca:
